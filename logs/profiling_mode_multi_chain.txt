/home/criserv/Documents/SISSA/Development Tools/devtools_scicomp_project_2025/experiments/config_multi_chain.yaml
{'N': 2000, 'N_samples': 500, 'seed': 1234, 'p': 20, 'dt_samples': 1, 'T': 1.0, 'mode': 'multi_chain', 'N_walkers': 3}
Running with numpy backend
Running with numba backend
Running with jax backend
Wrote profile results to run_profile.py.lprof
Timer unit: 1e-06 s

Total time: 0 s
File: /home/criserv/Documents/SISSA/Development Tools/devtools_scicomp_project_2025/src/spin_sampler/gibbs_steps.py
Function: gibbs_step_single_chain at line 16

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    16                                           @profile
    17                                           def gibbs_step_single_chain(S, J, T, rnd_ord = True , key = None):
    18                                               """
    19                                               One full update of spin state using Gibbs sampling for 
    20                                               single chain with J.
    21                                           
    22                                               Parameters:
    23                                               -----------
    24                                               - S: Spin configuration shape (N,).
    25                                               - J: Coupling matrix (shape (N, N)).
    26                                               - T: Temperature.
    27                                               - rnd_ord: If True, update spins in random order.
    28                                               - key: Dummy variable for compatibility with JAX functions.
    29                                           
    30                                               Returns:
    31                                               --------
    32                                               - Updated spin configuration and dummy variable.
    33                                               """
    34                                               beta = 1 / T  
    35                                               N = len(S)
    36                                           
    37                                               # Define the update order
    38                                               idx = np.random.permutation(N) if rnd_ord else np.arange(N)
    39                                           
    40                                               # Update sequentially the spins
    41                                               for i in idx:
    42                                                   h_i = S @ J[i]
    43                                                   p_plus = prob_plus(beta * h_i)
    44                                                   rand_vals = np.random.rand()
    45                                                   S[i] = 1 if rand_vals < p_plus else -1
    46                                               return S , key

Total time: 28.086 s
File: /home/criserv/Documents/SISSA/Development Tools/devtools_scicomp_project_2025/src/spin_sampler/gibbs_steps.py
Function: gibbs_step_multi_chain at line 48

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    48                                           @profile
    49                                           def gibbs_step_multi_chain(S, J, T, rnd_ord = True,  key = None):
    50                                               """
    51                                               One full update of spin state using Gibbs sampling for 
    52                                               multiple chains with same J.
    53                                           
    54                                               Parameters:
    55                                               -----------
    56                                               - S: Spin configuration shape (N_walkers,N).
    57                                               - J: Coupling matrix (shape (N, N)).
    58                                               - T: Temperature.
    59                                               - rnd_ord: If True, update spins in random order.
    60                                               - key: Dummy variable for compatibility with JAX functions.
    61                                           
    62                                               Returns:
    63                                               --------
    64                                               - Updated spin configuration and dummy variable.
    65                                               """
    66       500        583.3      1.2      0.0      beta = 1 / T  
    67       500        755.1      1.5      0.0      N_walkers , N = S.shape
    68                                           
    69                                               # Define the update order
    70       500      32784.9     65.6      0.1      idx = np.random.permutation(N) if rnd_ord else np.arange(N)
    71                                           
    72                                               # Update sequentially the spins
    73   1000500     499579.8      0.5      1.8      for i in idx:
    74   1000000    6579821.6      6.6     23.4          h_i = S @ J[i]
    75   1000000   11818354.3     11.8     42.1          p_plus = prob_plus(beta * h_i)
    76   1000000    2887706.0      2.9     10.3          rand_vals = np.random.rand(N_walkers)
    77   1000000    6266237.2      6.3     22.3          S[:, i] = np.where(rand_vals < p_plus, 1, -1)
    78       500        186.5      0.4      0.0      return S , key

Total time: 0 s
File: /home/criserv/Documents/SISSA/Development Tools/devtools_scicomp_project_2025/src/spin_sampler/gibbs_steps.py
Function: gibbs_step_multi_couplings at line 80

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    80                                           @profile
    81                                           def gibbs_step_multi_couplings(S, J, T, rnd_ord = True , key = None):
    82                                               """
    83                                               One full update of spin state using Gibbs sampling for 
    84                                               multiple chains with different J.
    85                                           
    86                                               Parameters:
    87                                               -----------
    88                                               - S: Spin configuration (shape (N_walkers, N)).
    89                                               - J: Coupling matrices (shape (N_walkers, N, N)).
    90                                               - T: Temperature.
    91                                               - rnd_ord: If True, update spins in random order.
    92                                               - key: Dummy variable for compatibility with JAX functions.
    93                                           
    94                                               Returns:
    95                                               --------
    96                                               - Updated spin configuration and dummy variable.
    97                                               """
    98                                               beta = 1 / T  
    99                                               N_walkers, N = S.shape
   100                                           
   101                                               # Define the update order
   102                                               idx = np.random.permutation(N) if rnd_ord else np.arange(N)
   103                                           
   104                                               # Update sequentially the spins
   105                                               for i in idx:
   106                                                   h_i = np.sum(J[:, i] * S, axis=1)
   107                                                   p_plus = prob_plus(beta * h_i)
   108                                                   rand_vals = np.random.rand(N_walkers)
   109                                                   S[:, i] = np.where(rand_vals < p_plus, 1, -1)
   110                                               return S  , key

Total time: 48.2919 s
File: /home/criserv/Documents/SISSA/Development Tools/devtools_scicomp_project_2025/src/spin_sampler/sampling.py
Function: sample at line 90

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    90                                               @profile
    91                                               def sample(self, initial_state, N_samples = 1, dt_samples = 1, rnd_ord=True, seed=None, store=False , progress = False):
    92                                                   """
    93                                                   Run Gibbs sampling as a generator.
    94                                           
    95                                                   Parameters:
    96                                                   -----------
    97                                                   - initial_state: Initial spin configuration. If None, use the last state in chain
    98                                                   - N_samples: Total number of steps to perform.
    99                                                   - dt_samples: Save every 'dt_samples' steps to reduce correlation.
   100                                                   - rnd_ord: If True, update spins in random order.
   101                                                   - seed: Optional seed for random number generation (int) / mandatory for jax.
   102                                                   - store: If True, store the sampled states in memory.
   103                                                   - progress: If True, display a progress bar.
   104                                           
   105                                                   Yields:
   106                                                   ----------
   107                                                   - The sampled state at each step (after thinning).
   108                                                   """
   109                                               
   110                                                   # Validate initial_state
   111         3          5.3      1.8      0.0          if self.backend == 'jax':
   112         1         38.5     38.5      0.0              if not isinstance(initial_state, jnp.ndarray):
   113                                                           raise TypeError('initial state must be a jax array.') 
   114         1          2.9      2.9      0.0              if seed == None:
   115                                                           raise ValueError('Must specify seed when using jax.')
   116                                                   else: 
   117         2          3.3      1.7      0.0              if not isinstance(initial_state, np.ndarray):
   118                                                           raise TypeError('initial_state must be a numpy array.')
   119                                                       
   120         3          4.6      1.5      0.0          if self.mode == 'single_chain' and initial_state.ndim != 1:
   121                                                       raise ValueError("For 'single_chain', initial_state must be 1D.")
   122         3         23.1      7.7      0.0          if self.mode in ['multi_chain', 'multi_couplings'] and initial_state.ndim != 2:
   123                                                       raise ValueError(f"For '{self.mode}', initial_state must be 2D.")
   124         3          2.3      0.8      0.0          if self.mode == 'single_chain' and initial_state.shape[0] != self.J.shape[0]:
   125                                                       raise ValueError("Initial state size does not match J dimensions.")
   126         3         11.1      3.7      0.0          if self.mode == 'multi_chain' and initial_state.shape[1] != self.J.shape[0]:
   127                                                       raise ValueError("Initial state size does not match J dimensions.")
   128         3          3.0      1.0      0.0          if self.mode == 'multi_couplings' and (initial_state.shape[0] != self.J.shape[0] or initial_state.shape[1] != self.J.shape[1]):
   129                                                       raise ValueError("Initial state size does not match J dimensions.")
   130                                           
   131                                                   # Initialize random seed
   132         3          1.8      0.6      0.0          if seed is not None:
   133         3          2.1      0.7      0.0              if self.backend == 'jax': 
   134         1       2450.3   2450.3      0.0                  key = jax.random.PRNGKey(seed)
   135                                                       else:
   136         2         33.0     16.5      0.0                  np.random.seed(seed)
   137         2          0.8      0.4      0.0                  key = 42
   138                                                   else:
   139                                                       key = 42  # Dummy key for non-jax backends
   140                                           
   141                                                   # Check if chain is empty, if not, print a warning
   142         3         11.3      3.8      0.0          if (not len(self.chain) == 0) and store:
   143                                                       print(f"Warning: The chain is not empty, contains {len(self.chain)} elements. New samples will be appended to the existing chain.")
   144                                           
   145         3      82974.6  27658.2      0.2          S = initial_state.copy()
   146         3       8620.9   2873.6      0.0          pbar = get_progress_bar(progress, N_samples)
   147                                           
   148                                                   # Main sampling loop
   149      1503       1831.5      1.2      0.0          for step in range(N_samples*dt_samples):
   150      1500   47502754.7  31668.5     98.4              S , key = self.step(S,rnd_ord=rnd_ord,key=key)  # Perform one Gibbs sampling step
   151                                                       # Save or yield the state every `thin_by` steps
   152      1500       3469.8      2.3      0.0              if step % dt_samples == 0:
   153      1500        789.0      0.5      0.0                  if store:
   154      1500     407259.9    271.5      0.8                      self.chain.append((S.astype(self.spin_dtype)).copy())
   155      1500     107881.5     71.9      0.2                  yield S.copy()
   156      1500     170545.1    113.7      0.4              pbar.update(1)
   157         3       3182.6   1060.9      0.0          pbar.close()

Total time: 59.9689 s
File: scripts/run_profile.py
Function: main at line 9

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     9                                           @profile
    10                                           def main():
    11                                               # Parse argument
    12         1        562.5    562.5      0.0      parser = argparse.ArgumentParser()
    13         2         70.1     35.0      0.0      parser.add_argument('-c','--config',type=str,
    14         1          0.2      0.2      0.0                          help='Configuration file for the experiment')
    15         1        238.2    238.2      0.0      args = parser.parse_args()
    16         1          0.4      0.4      0.0      config_path = args.config
    17                                           
    18                                               # Read the configuration file
    19         1       2632.1   2632.1      0.0      conf = read_config(config_path)
    20         1          7.4      7.4      0.0      print(conf)
    21                                           
    22                                               # Define parameters
    23         1          0.5      0.5      0.0      mode = conf['mode']
    24         1          0.2      0.2      0.0      N = conf['N']
    25         1          0.3      0.3      0.0      N_walkers = conf['N_walkers']
    26         1          0.3      0.3      0.0      N_samples = conf['N_samples']
    27         1          0.3      0.3      0.0      dt_samples = conf['dt_samples']
    28         1          0.3      0.3      0.0      T = conf['T']
    29         1          0.3      0.3      0.0      seed = conf['seed']
    30         1          0.3      0.3      0.0      p = conf['p']
    31                                           
    32                                               # Run
    33         1          0.3      0.3      0.0      backend = 'numpy'
    34         1          0.7      0.7      0.0      print("Running with numpy backend")
    35         1      79564.3  79564.3      0.1      J , _ = define_hopfield_model(N,p,N_walkers if mode=='multi_couplings' else 1,mode=mode,backend=backend,seed=seed)
    36         1        260.4    260.4      0.0      S0 = initialize_spins(N,N_walkers,mode=mode,backend=backend,seed=seed)
    37         1     133645.0 133645.0      0.2      sampler = Sampler(J, T, mode = mode,backend=backend)
    38         1   30398354.4    3e+07     50.7      sampler.run_gibbs(S0, N_samples=N_samples, dt_samples=dt_samples,seed=seed, store=True,progress=True);
    39                                           
    40         1          0.5      0.5      0.0      backend = 'numba'
    41         1          5.3      5.3      0.0      print("Running with numba backend")
    42         1     221647.5 221647.5      0.4      J , _ = define_hopfield_model(N,p,N_walkers if mode=='multi_couplings' else 1,mode=mode,backend=backend,seed=seed)
    43         1        277.9    277.9      0.0      S0 = initialize_spins(N,N_walkers,mode=mode,backend=backend,seed=seed)
    44         1     135762.9 135762.9      0.2      sampler = Sampler(J, T, mode = mode,backend=backend)
    45         1   13821976.7    1e+07     23.0      sampler.run_gibbs(S0, N_samples=N_samples, dt_samples=dt_samples,seed=seed, store=True,progress=True);
    46                                           
    47         1          2.9      2.9      0.0      backend = 'jax'
    48         1         19.6     19.6      0.0      print("Running with jax backend")
    49         1    7410386.8    7e+06     12.4      J , _ = define_hopfield_model(N,p,N_walkers if mode=='multi_couplings' else 1,mode=mode,backend=backend,seed=seed)
    50         1    3103882.6    3e+06      5.2      S0 = initialize_spins(N,N_walkers,mode=mode,backend=backend,seed=seed)
    51         1     548615.9 548615.9      0.9      sampler = Sampler(J, T, mode = mode,backend=backend)
    52         1    4110997.3    4e+06      6.9      sampler.run_gibbs(S0, N_samples=N_samples, dt_samples=dt_samples,seed=seed, store=True,progress=True);

